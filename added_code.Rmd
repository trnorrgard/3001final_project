---
title: "finalcode"
author: "ash2sfp"
date: "12/2/2021"
output: html_document
---

```{r}
# we need rating, price, room type, neighborhood, superhost, property_type, accomodates
boston <- read_csv("Boston_Airbnb_copy.csv")
boston <- boston%>%
  select(c("neighbourhood_cleansed", "room_type", 
           "accommodates", "price", "review_scores_rating", 
           "host_is_superhost", "property_type"))

boston <-  boston%>%
  rename(superhost = host_is_superhost, neighborhood = neighbourhood_cleansed, rating=review_scores_rating)

boston$price = as.numeric(gsub("\\$", "", boston$price))

boston <- boston[complete.cases(boston),] # removes NA's

##Factor Collapse
table(boston$neighborhood)


boston$neighborhood <- fct_collapse(boston$neighborhood, 
                                    north = c("East Boston", "Charlestown", "Allston", "Brighton", "Fenway", "Back Bay", "Beacon Hill", "West End", "North End", "Chinatown", "Longwood Medical Area", "Bay Village", "Downtown"), south = c("South End", "South Boston", "Mission Hill", "West Roxbury", "Leather District", "Dorchester", "Mattapan", "Hyde Park", "Jamaica Plain", "Roslindale", "Roxbury", "South Boston Waterfront"))

table(boston$neighborhood)

table(boston$room_type)
boston$room_type <- as.factor(boston$room_type)

table(boston$accommodates)

table(boston$rating)
boston$rating <- ifelse(boston$rating<95, "0", "1")
boston$rating <- as.factor(boston$rating)

boston$superhost <- as.factor(boston$superhost)
boston$superhost <- recode(boston$superhost,
                       'FALSE'="no",'TRUE'="yes") 

table(boston$property_type)

boston$property_type <- fct_collapse(boston$property_type, 
                                     room = c("Dorm", "Loft"),
                                     partial_home = c("Guesthouse", "Entire Floor"),
                                     home = c("House", "Apartment", "Townhouse", "Villa", "Condominium"),
                                     other = c("Bed & Breakfast", "Boat", "Other"))

scaled_boston <- as.data.frame(scale(boston[3:4], center = TRUE, scale = TRUE))

boston <- boston[,-c(3,4)]
boston <- cbind(scaled_boston, boston)
```

```{r}
### creating train tune test
library(caret)
library(tidyverse)
library(class)
library(plotly)

part_index_1 <- createDataPartition(boston$rating,
                                           times=1,
                                           p = 0.70,
                                           groups=1,
                                           list=FALSE)
View(part_index_1)
train <- boston[part_index_1,]
tune_and_test <- boston[-part_index_1, ]

tune_and_test_index <- createDataPartition(tune_and_test$rating,
                                           p = .5,
                                           list = FALSE,
                                           times = 1)
tune <- tune_and_test[tune_and_test_index, ]
test <- tune_and_test[-tune_and_test_index, ]
dim(train)
dim(tune)
dim(test)

```

```{r}
### Running knn

trctrl <- trainControl(method = "repeatedcv",
                       number = 50,
                       repeats = 10)

boston_knn <- train(rating~.,
                  data = train,
                  method="knn",
                  tuneLength=10,
                  trControl= trctrl,
                  preProcess="scale")

boston_knn

varImp(boston_knn)

boston_pred <- predict(boston_knn, train)

confusionMatrix(boston_pred, train$rating)

confusionMatrix(as.factor(boston_knn), as.factor(tune$rating), positive = "1", dnn=c("Prediction", "Actual"), mode = "sens_spec")

```
## make sure we chose correct k
```{r}

chooseK = function(k, train_set, val_set, train_class, val_class){
  
  # Build knn with k neighbors considered.
  set.seed(1)
  class_knn = knn(train = train_set,    #<- training set cases
                  test = val_set,       #<- test set cases
                  cl = train_class,     #<- category for classification
                  k = k,                #<- number of neighbors considered
                  use.all = TRUE)       #<- control ties between class assignments
                                        #   If true, all distances equal to the kth 
                                        #   largest are included
  conf_mat = table(class_knn, val_class)
  
  # Calculate the accuracy.
  accu = sum(conf_mat[row(conf_mat) == col(conf_mat)]) / sum(conf_mat)                         
  cbind(k = k, accuracy = accu)
}



# The sapply() function plugs in several values into our chooseK function.
#sapply(x, fun...) "fun" here is passing a function to our k-function
# function(x)[function] allows you to apply a series of numbers
# to a function without running a for() loop! Returns a matrix.
knn_different_k = sapply(seq(1, 21, by = 2),  #<- set k to be odd number from 1 to 21
                         function(x) chooseK(x, 
                          train_set = train[, c("property_type", "superhost", "room_type", "neighborhood", "price", "accommodates")],
                          val_set = tune[, c("property_type", "superhost", "room_type", "neighborhood", "price", "accommodates")],
                          train_class = train$rating,
                          val_class = tune$rating))

sum(is.na(train$rating))

#A bit more of a explanation...
seq(1,21, by=2)#just creates a series of numbers
sapply(seq(1, 21, by=2), function(x) x+1)#sapply returns a new vector using the series of numbers and some calculation that is repeated over the vector of numbers 


# Reformating the results to graph
View(knn_different_k)
class(knn_different_k)#matrix 
head(knn_different_k)

knn_different_k = data.frame(k = knn_different_k[1,],
                             accuracy = knn_different_k[2,])

# Plot accuracy vs. k.

ggplot(knn_different_k,
       aes(x = k, y = accuracy)) +
  geom_line(color = "orange", size = 1.5) +
  geom_point(size = 3)

# 5 to 7 nearest neighbors seems to be a good choice because that's the
# greatest improvement in predictive accuracy before the incremental 
# improvement trails off.
```









